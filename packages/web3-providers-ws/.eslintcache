[{"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/src/index.ts":"1","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/proxy.ts":"2","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/system_test_utils.ts":"3","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/test_data.ts":"4","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/basic_auth.test.ts":"5","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/eip1193.test.ts":"6","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/ganache_fault_tolerance.test.ts":"7","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/reconnection.test.ts":"8","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/web_socket_provider_integration.test.ts":"9","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/__mocks__/isomorphic-ws.ts":"10","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/check_implementation.test.ts":"11","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/web_socket_provider.test.ts":"12"},{"size":5617,"mtime":1679687265391,"results":"13","hashOfConfig":"14"},{"size":2101,"mtime":1679686929291,"results":"15","hashOfConfig":"16"},{"size":15907,"mtime":1713826363670,"results":"17","hashOfConfig":"16"},{"size":1224,"mtime":1678154646163,"results":"18","hashOfConfig":"16"},{"size":2932,"mtime":1705453104096,"results":"19","hashOfConfig":"16"},{"size":3468,"mtime":1682532947998,"results":"20","hashOfConfig":"16"},{"size":13202,"mtime":1701873231384,"results":"21","hashOfConfig":"16"},{"size":4878,"mtime":1682532947999,"results":"22","hashOfConfig":"16"},{"size":8563,"mtime":1709850520297,"results":"23","hashOfConfig":"16"},{"size":1455,"mtime":1709850520297,"results":"24","hashOfConfig":"16"},{"size":5680,"mtime":1709850520298,"results":"25","hashOfConfig":"16"},{"size":3332,"mtime":1684618137115,"results":"26","hashOfConfig":"16"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1o8fjvf",{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1fs4g3n",{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46"},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54"},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58"},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65"},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69"},"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/src/index.ts",[],["70","71"],"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/proxy.ts",[],["72"],"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/system_test_utils.ts",[],["73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89"],"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/fixtures/test_data.ts",[],["90"],"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/basic_auth.test.ts",["91"],[],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport express from 'express';\nimport { Server } from 'http';\nimport { createProxyMiddleware } from 'http-proxy-middleware';\nimport WebSocketProvider from '../../src/index';\nimport {\n\tdescribeIf,\n\tgetSystemTestProviderUrl,\n\tisWs,\n\twaitForSocketConnect,\n\twaitForCloseSocketConnection,\n} from '../fixtures/system_test_utils';\n\ndescribeIf(isWs)('Support of Basic Auth', () => {\n\tlet server: Server;\n\tlet clientWsUrl: string;\n\tlet webSocketProvider: WebSocketProvider;\n\n\tbeforeAll(() => {\n\t\tclientWsUrl = getSystemTestProviderUrl();\n\t\tconst app = express();\n\t\tconst port = 3000;\n\t\tconst host = 'localhost';\n\n\t\tconst wsProxy = createProxyMiddleware({\n\t\t\ttarget: clientWsUrl,\n\t\t\tchangeOrigin: true,\n\t\t\tws: true,\n\t\t\tonError: () => {\n\t\t\t\tconsole.warn('************** proxy error');\n\t\t\t},\n\t\t\tlogLevel: 'silent',\n\t\t});\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\t\tapp.use(wsProxy);\n\t\tserver = app.listen(port, host);\n\n\t\tserver.on('upgrade', (req, socket, head) => {\n\t\t\tif (!req.headers.authorization || !req.headers.authorization?.includes('Basic ')) {\n\t\t\t\tsocket.emit('error');\n\t\t\t\tsocket.destroy();\n\t\t\t}\n\t\t\tconst base64Credentials = req.headers.authorization?.split(' ')[1];\n\t\t\tconst credentials: string = Buffer.from(base64Credentials as string, 'base64').toString(\n\t\t\t\t'ascii',\n\t\t\t);\n\t\t\tconst [username, password] = credentials.split(':');\n\t\t\tif (username !== 'geth' || password !== 'authpass') {\n\t\t\t\tsocket.emit('error');\n\t\t\t\tsocket.destroy();\n\t\t\t}\n\t\t\treturn wsProxy.upgrade?.(req as any, socket as any, head);\n\t\t});\n\t});\n\tafterAll(() => {\n\t\tserver.close();\n\t});\n\tbeforeEach(() => {\n\t\twebSocketProvider = new WebSocketProvider(\n\t\t\t'ws://geth:authpass@localhost:3000',\n\t\t\t{},\n\t\t\t{ delay: 1, autoReconnect: false, maxAttempts: 1 },\n\t\t);\n\t});\n\tafterEach(async () => {\n\t\t// make sure we try to close the connection after it is established\n\t\tif (webSocketProvider.getStatus() === 'connecting') {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t}\n\t\twebSocketProvider.disconnect();\n\t\tawait waitForCloseSocketConnection(webSocketProvider);\n\t});\n\t// eslint-disable-next-line jest/expect-expect\n\ttest('should connect with basic auth', async () => {\n\t\tawait waitForSocketConnect(webSocketProvider);\n\t\texpect(webSocketProvider.getStatus()).toBe('connected');\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/eip1193.test.ts",["92"],[],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { hexToNumber } from 'web3-utils';\nimport { HexString, ProviderConnectInfo, ProviderRpcError } from 'web3-types';\nimport WebSocketProvider from '../../src/index';\n\nimport {\n\tdescribeIf,\n\tgetSystemTestProviderUrl,\n\tisWs,\n\twaitForSocketConnect,\n\twaitForSocketDisconnect,\n} from '../fixtures/system_test_utils';\n\ndescribeIf(isWs)('WebSocketProvider - eip1193', () => {\n\tlet socketPath: string;\n\tlet socketProvider: WebSocketProvider;\n\n\tbeforeAll(() => {\n\t\tsocketPath = getSystemTestProviderUrl();\n\t});\n\tbeforeEach(() => {\n\t\tsocketProvider = new WebSocketProvider(socketPath);\n\t});\n\tafterEach(async () => {\n\t\tsocketProvider.disconnect(1000);\n\t\tawait waitForSocketDisconnect(socketProvider);\n\t});\n\n\tdescribe('check events', () => {\n\t\tit('should send connect event', async () => {\n\t\t\tconst providerConnectInfo = await new Promise<ProviderConnectInfo>(resolve => {\n\t\t\t\tsocketProvider.on('connect', (data: ProviderConnectInfo) => {\n\t\t\t\t\tresolve(data);\n\t\t\t\t});\n\t\t\t});\n\t\t\texpect(hexToNumber(providerConnectInfo.chainId)).toBeGreaterThan(0);\n\t\t});\n\t\tit('should send disconnect event', async () => {\n\t\t\tawait waitForSocketConnect(socketProvider);\n\t\t\tconst disconnectPromise = new Promise<ProviderRpcError>(resolve => {\n\t\t\t\tsocketProvider.on('disconnect', (error: ProviderRpcError) => {\n\t\t\t\t\tresolve(error);\n\t\t\t\t});\n\t\t\t});\n\t\t\tsocketProvider.disconnect(1000, 'Some extra data');\n\n\t\t\tconst err = await disconnectPromise;\n\t\t\texpect(err.code).toBe(1000);\n\t\t\texpect(err.data).toBe('Some extra data');\n\t\t});\n\t\tit('should send chainChanged event', async () => {\n\t\t\tawait waitForSocketConnect(socketProvider);\n\t\t\t// @ts-expect-error set private variable\n\t\t\tsocketProvider._chainId = '0x1';\n\t\t\tsocketProvider.disconnect(1000);\n\t\t\tawait waitForSocketDisconnect(socketProvider);\n\t\t\tconst chainChangedPromise = new Promise<HexString>(resolve => {\n\t\t\t\tsocketProvider.on('chainChanged', (result: HexString) => {\n\t\t\t\t\tresolve(result);\n\t\t\t\t});\n\t\t\t});\n\t\t\tsocketProvider.connect();\n\t\t\tawait waitForSocketConnect(socketProvider);\n\t\t\tconst chainId = await chainChangedPromise;\n\t\t\texpect(chainId).not.toBe('0x1');\n\t\t\texpect(hexToNumber(chainId)).toBeGreaterThan(0);\n\t\t});\n\t\tit('should send accountsChanged event', async () => {\n\t\t\tawait waitForSocketConnect(socketProvider);\n\n\t\t\t// @ts-expect-error set private variable\n\t\t\tsocketProvider._accounts = ['1', '2'];\n\t\t\tsocketProvider.disconnect(1000);\n\t\t\tawait waitForSocketDisconnect(socketProvider);\n\t\t\tconst chainChangedPromise = new Promise<HexString[]>(resolve => {\n\t\t\t\tsocketProvider.on('accountsChanged', (accounts: HexString[]) => {\n\t\t\t\t\tresolve(accounts);\n\t\t\t\t});\n\t\t\t});\n\t\t\tsocketProvider.connect();\n\t\t\tawait waitForSocketConnect(socketProvider);\n\t\t\tconst accounts = await chainChangedPromise;\n\n\t\t\texpect(JSON.stringify(accounts)).not.toBe(JSON.stringify(['1', '2']));\n\t\t});\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/ganache_fault_tolerance.test.ts",["93"],["94","95","96","97","98"],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { ProviderRpcError } from 'web3-types/src/web3_api_types';\nimport ganache from 'ganache';\nimport { EthExecutionAPI, Web3APIPayload, SocketRequestItem, JsonRpcResponse } from 'web3-types';\nimport { InvalidResponseError, ConnectionNotOpenError } from 'web3-errors';\nimport { Web3DeferredPromise } from 'web3-utils';\nimport {\n\twaitForSocketConnect,\n\twaitForEvent,\n\tdescribeIf,\n\tgetSystemTestBackend,\n\tisWs,\n} from '../fixtures/system_test_utils';\nimport WebSocketProvider from '../../src/index';\n\n// create helper functions to open server\ndescribeIf(getSystemTestBackend() === 'ganache' && isWs)('ganache tests', () => {\n\tdescribe('WebSocketProvider - ganache', () => {\n\t\tjest.setTimeout(17000);\n\t\tconst port = 7547;\n\t\tconst host = `ws://localhost:${port}`;\n\t\tconst jsonRpcPayload = {\n\t\t\tjsonrpc: '2.0',\n\t\t\tid: 43,\n\t\t\tmethod: 'eth_mining',\n\t\t} as Web3APIPayload<EthExecutionAPI, 'eth_mining'>;\n\n\t\t// simulate abrupt disconnection, ganache server always closes with code 1000 so we need to simulate closing with different error code\n\t\tconst changeCloseCode = async (webSocketProvider: WebSocketProvider) =>\n\t\t\tnew Promise<void>(resolve => {\n\t\t\t\t// @ts-expect-error replace close handler\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars, no-param-reassign\n\t\t\t\twebSocketProvider._onCloseHandler = (_: CloseEvent) => {\n\t\t\t\t\t// @ts-expect-error replace close event\n\t\t\t\t\twebSocketProvider._onCloseEvent({ code: 1003 });\n\t\t\t\t};\n\t\t\t\t// @ts-expect-error run protected method\n\t\t\t\twebSocketProvider._removeSocketListeners();\n\t\t\t\t// @ts-expect-error run protected method\n\t\t\t\twebSocketProvider._addSocketListeners();\n\t\t\t\tresolve();\n\t\t\t});\n\n\t\tit('\"error\" when there is no connection', async () => {\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 100,\n\t\t\t\tautoReconnect: false,\n\t\t\t\tmaxAttempts: 1,\n\t\t\t};\n\t\t\tconst websocketProvider = new WebSocketProvider(\n\t\t\t\t'ws://localhost:7547',\n\t\t\t\t{},\n\t\t\t\treconnectionOptions,\n\t\t\t);\n\n\t\t\texpect(!!(await waitForEvent(websocketProvider, 'error'))).toBe(true);\n\t\t\twebsocketProvider.disconnect();\n\t\t\tawait expect(websocketProvider.request(jsonRpcPayload)).rejects.toThrow(\n\t\t\t\t'Connection not open',\n\t\t\t);\n\t\t});\n\n\t\tit('\"error\" handler fires if the client closes unilaterally', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst webSocketProvider = new WebSocketProvider(host);\n\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\tconst disconnectPromise = waitForEvent(webSocketProvider, 'disconnect');\n\t\t\tawait server.close();\n\t\t\texpect(!!(await disconnectPromise)).toBe(true);\n\t\t\twebSocketProvider.disconnect();\n\t\t});\n\n\t\tit('\"error\" handler *DOES NOT* fire if disconnection is clean', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectOptions = {\n\t\t\t\tautoReconnect: false,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectOptions);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\tconst mockReject = jest.fn();\n\t\t\twebSocketProvider.once('error', () => {\n\t\t\t\tmockReject();\n\t\t\t});\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait new Promise(resolve => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve(true);\n\t\t\t\t}, 100);\n\t\t\t});\n\t\t\texpect(mockReject).toHaveBeenCalledTimes(0);\n\n\t\t\tawait server.close();\n\t\t});\n\n\t\tit('can connect after being disconnected', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\n\t\t\tconst webSocketProvider = new WebSocketProvider(host);\n\t\t\tconst mockCallback = jest.fn();\n\t\t\tconst connectPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.once('connect', () => {\n\t\t\t\t\tmockCallback();\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait connectPromise;\n\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait waitForEvent(webSocketProvider, 'disconnect');\n\n\t\t\twebSocketProvider.connect();\n\t\t\tconst connectPromise2 = new Promise(resolve => {\n\t\t\t\twebSocketProvider.once('connect', () => {\n\t\t\t\t\tmockCallback();\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait connectPromise2;\n\t\t\twebSocketProvider.disconnect();\n\t\t\texpect(mockCallback).toHaveBeenCalledTimes(2);\n\t\t\tawait server.close();\n\t\t});\n\n\t\tit('webSocketProvider supports subscriptions', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst webSocketProvider = new WebSocketProvider(host);\n\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\texpect(webSocketProvider.supportsSubscriptions()).toBe(true);\n\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait server.close();\n\t\t});\n\n\t\tit('times out when server is closed', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 100,\n\t\t\t\tautoReconnect: false,\n\t\t\t\tmaxAttempts: 1,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\t\t\tconst mockCallBack = jest.fn();\n\t\t\tconst errorPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('error', (err: unknown) => {\n\t\t\t\t\tif ((err as ProviderRpcError)?.message.startsWith('connect ECONNREFUSED')) {\n\t\t\t\t\t\tmockCallBack();\n\t\t\t\t\t\tresolve(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait server.close();\n\t\t\tawait errorPromise;\n\t\t\texpect(mockCallBack).toHaveBeenCalled();\n\t\t});\n\n\t\tit('with reconnect on, will try to connect until server is open then close', async () => {\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 10,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 100,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\n\t\t\tconst mockCallback = jest.fn();\n\t\t\tconst connectPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('connect', () => {\n\t\t\t\t\tmockCallback();\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tawait connectPromise;\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait server.close();\n\t\t\texpect(mockCallback).toHaveBeenCalledTimes(1);\n\t\t});\n\n\t\tit('allows disconnection on lost connection, when reconnect is enabled', async () => {\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 10,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 100,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\n\t\t\tconst connectPromise = waitForSocketConnect(webSocketProvider);\n\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tawait connectPromise;\n\t\t\tawait server.close();\n\t\t\tconst disconnectEvent = waitForEvent(webSocketProvider, 'disconnect');\n\t\t\twebSocketProvider.disconnect();\n\t\t\texpect(!!(await disconnectEvent)).toBe(true);\n\t\t});\n\n\t\tit('errors when failing to reconnect after data is lost mid-chunk', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 100,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 1,\n\t\t\t};\n\t\t\tconst mockCallBack = jest.fn();\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\twebSocketProvider.on('error', (err: any) => {\n\t\t\t\tif (err.message === `Maximum number of reconnect attempts reached! (${1})`) {\n\t\t\t\t\tmockCallBack();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tawait server.close();\n\n\t\t\t// when server is not listening send request, and expect that lib will try to reconnect and at end will throw con not open error\n\t\t\tawait expect(\n\t\t\t\twebSocketProvider.request(\n\t\t\t\t{\"method\":\"eth_getBlockByNumber\",\"params\":[\"0xc5043f\",false],\"id\":1,\"jsonrpc\":\"2.0\"}\n\t\t\t\t))\n\t\t\t\t.rejects.toThrow(ConnectionNotOpenError);\n\n\t\t\texpect(mockCallBack).toHaveBeenCalled();\n\t\t});\n\n\t\tit('times out when connection is lost mid-chunk', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 0,\n\t\t\t\tautoReconnect: false,\n\t\t\t\tmaxAttempts: 0,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\tawait server.close();\n\n\t\t\tconst errorPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('error', (err: any) => {\n\t\t\t\t\texpect(err).toBeInstanceOf(InvalidResponseError);\n\t\t\t\t\tif (err.cause.message === 'Chunk timeout') {\n\t\t\t\t\t\tresolve(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\t// send an event to be parsed and fail\n\t\t\tconst event = {\n\t\t\t\tdata: 'abc|--|ded',\n\t\t\t\ttype: 'websocket',\n\t\t\t\t// @ts-expect-error run protected method\n\t\t\t\ttarget: webSocketProvider._socketConnection,\n\t\t\t};\n\t\t\t// @ts-expect-error run protected method\n\t\t\twebSocketProvider._parseResponses(event); // simulate chunks\n\t\t\tawait errorPromise;\n\t\t\texpect(true).toBe(true);\n\t\t});\n\n\t\tit('clears pending requests on maxAttempts failed reconnection', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 1000,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 1,\n\t\t\t};\n\t\t\tconst mockCallBack = jest.fn();\n\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\t\t\tconst defPromise = new Web3DeferredPromise<JsonRpcResponse<ResponseType>>();\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\t\tdefPromise.catch(() => {});\n\t\t\tconst reqItem: SocketRequestItem<any, any, any> = {\n\t\t\t\tpayload: jsonRpcPayload,\n\t\t\t\tdeferredPromise: defPromise,\n\t\t\t};\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\t// add a request without executing promise\n\t\t\t// @ts-expect-error run protected method\n\t\t\twebSocketProvider._pendingRequestsQueue.set(jsonRpcPayload.id, reqItem);\n\n\t\t\t// simulate abrupt server close\n\t\t\tawait changeCloseCode(webSocketProvider);\n\t\t\tconst errorPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('error', (error: unknown) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t(error as ProviderRpcError)?.message ===\n\t\t\t\t\t\t`Maximum number of reconnect attempts reached! (${1})`\n\t\t\t\t\t) {\n\t\t\t\t\t\tmockCallBack();\n\t\t\t\t\t}\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tawait server.close();\n\t\t\tawait errorPromise;\n\t\t\t// @ts-expect-error run protected method\n\t\t\texpect(webSocketProvider._pendingRequestsQueue.size).toBe(0);\n\t\t\texpect(mockCallBack).toHaveBeenCalled();\n\t\t});\n\n\t\tit('queues requests made while connection is lost / executes on reconnect', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectionOptions = {\n\t\t\t\tdelay: 1000,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 3,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectionOptions);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\t// simulate abrupt close code\n\t\t\tawait changeCloseCode(webSocketProvider);\n\t\t\tconst errorPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('error', () => {\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait server.close();\n\n\t\t\tawait errorPromise;\n\t\t\t// queue a request\n\t\t\tconst requestPromise = webSocketProvider.request(jsonRpcPayload);\n\n\t\t\tconst server2 = ganache.server();\n\t\t\tawait server2.listen(port);\n\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\t// try to send a request\n\t\t\tconst result = await requestPromise;\n\t\t\texpect(result.id).toEqual(jsonRpcPayload.id);\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait server2.close();\n\t\t});\n\t\tit('errors when requests continue after socket closed', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst reconnectOptions = {\n\t\t\t\tautoReconnect: false,\n\t\t\t};\n\t\t\tconst webSocketProvider = new WebSocketProvider(host, {}, reconnectOptions);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\tconst disconnectPromise = waitForEvent(webSocketProvider, 'disconnect');\n\t\t\tawait server.close();\n\n\t\t\tawait disconnectPromise;\n\t\t\tconst errorPromise = new Promise(resolve => {\n\t\t\t\twebSocketProvider.on('error', () => {\n\t\t\t\t\tresolve(true);\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait expect(webSocketProvider.request(jsonRpcPayload)).rejects.toThrow(\n\t\t\t\t'Connection not open',\n\t\t\t);\n\t\t\tawait errorPromise;\n\t\t});\n\t\tit('deferredPromise emits an error when request fails', async () => {\n\t\t\tconst server = ganache.server();\n\t\t\tawait server.listen(port);\n\t\t\tconst webSocketProvider = new WebSocketProvider(host);\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\n\t\t\t// @ts-expect-error replace sendtoSocket so we don't execute request\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\t\twebSocketProvider._sendToSocket = () => {};\n\t\t\twebSocketProvider.on('error', (err: unknown) => {\n\t\t\t\texpect(err).toBeInstanceOf(ConnectionNotOpenError);\n\t\t\t});\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\t\tconst request = webSocketProvider.request(jsonRpcPayload).catch(() => {});\n\n\t\t\t// @ts-expect-error create a deferred promise error\n\t\t\twebSocketProvider._clearQueues();\n\n\t\t\tawait request;\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait server.close();\n\t\t});\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/reconnection.test.ts",["99"],["100"],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { CloseEvent } from 'ws';\nimport { ProviderRpcError } from 'web3-types/src/web3_api_types';\nimport WebSocketProvider from '../../src';\n\nimport { createProxy } from '../fixtures/proxy';\nimport {\n\tdescribeIf,\n\tgetSystemTestProviderUrl,\n\tisBrowser,\n\twaitForSocketConnect,\n\tisWs,\n\twaitForCloseSocketConnection,\n\twaitForEvent,\n} from '../fixtures/system_test_utils';\n\ndescribeIf(isWs && !isBrowser)('WebSocketProvider - reconnection', () => {\n\tdescribe('subscribe event tests', () => {\n\t\tlet reconnectionOptions: {\n\t\t\tdelay: number;\n\t\t\tautoReconnect: boolean;\n\t\t\tmaxAttempts: number;\n\t\t};\n\t\tbeforeAll(() => {\n\t\t\treconnectionOptions = {\n\t\t\t\tdelay: 500,\n\t\t\t\tautoReconnect: true,\n\t\t\t\tmaxAttempts: 100,\n\t\t\t};\n\t\t});\n\t\tit('check defaults', async () => {\n\t\t\tconst web3Provider = new WebSocketProvider(getSystemTestProviderUrl());\n\t\t\t// @ts-expect-error-next-line\n\t\t\texpect(web3Provider._reconnectOptions).toEqual({\n\t\t\t\tautoReconnect: true,\n\t\t\t\tdelay: 5000,\n\t\t\t\tmaxAttempts: 5,\n\t\t\t});\n\t\t\tawait waitForSocketConnect(web3Provider);\n\t\t\tweb3Provider.disconnect(1000, 'test');\n\t\t\tawait waitForCloseSocketConnection(web3Provider);\n\t\t});\n\t\tit('set custom reconnectOptions', async () => {\n\t\t\tconst web3Provider = new WebSocketProvider(\n\t\t\t\tgetSystemTestProviderUrl(),\n\t\t\t\t{},\n\t\t\t\treconnectionOptions,\n\t\t\t);\n\t\t\t// @ts-expect-error-next-line\n\t\t\texpect(web3Provider._reconnectOptions).toEqual(reconnectionOptions);\n\t\t\tawait waitForSocketConnect(web3Provider);\n\t\t\tweb3Provider.disconnect(1000, 'test');\n\t\t\tawait waitForCloseSocketConnection(web3Provider);\n\t\t});\n\t\tit('should emit connect and disconnected events', async () => {\n\t\t\tconst server = await createProxy(18545, getSystemTestProviderUrl());\n\t\t\tconst web3Provider = new WebSocketProvider(server.path, {}, reconnectionOptions);\n\t\t\texpect(!!(await waitForEvent(web3Provider, 'connect'))).toBe(true);\n\t\t\t// @ts-expect-error set protected option\n\t\t\tweb3Provider._reconnectOptions = {\n\t\t\t\t...reconnectionOptions,\n\t\t\t\tautoReconnect: false,\n\t\t\t};\n\n\t\t\tconst disconnectPromise = waitForEvent(web3Provider, 'disconnect');\n\t\t\t// @ts-expect-error read protected property\n\t\t\texpect(web3Provider.isReconnecting).toBe(false);\n\t\t\tawait server.close();\n\n\t\t\texpect(!!(await disconnectPromise)).toBe(true);\n\t\t});\n\n\t\tit('should connect, disconnect and reconnect', async () => {\n\t\t\tconst server = await createProxy(18546, getSystemTestProviderUrl());\n\t\t\tconst web3Provider = new WebSocketProvider(server.path, {}, reconnectionOptions);\n\t\t\texpect(!!(await waitForEvent(web3Provider, 'connect'))).toBe(true);\n\t\t\tweb3Provider.disconnect(1002);\n\t\t\tawait server.close();\n\t\t\tconst connectEvent = waitForEvent(web3Provider, 'connect');\n\t\t\tconst server2 = await createProxy(18546, getSystemTestProviderUrl());\n\t\t\texpect(!!(await connectEvent)).toBe(true);\n\n\t\t\tweb3Provider.disconnect();\n\t\t\tawait waitForEvent(web3Provider, 'disconnect');\n\t\t\tawait server2.close();\n\t\t});\n\t\tit('should connect, disconnect, try reconnect and reach max attempts', async () => {\n\t\t\tconst server = await createProxy(18547, getSystemTestProviderUrl());\n\t\t\tconst web3Provider = new WebSocketProvider(\n\t\t\t\tserver.path,\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\t...reconnectionOptions,\n\t\t\t\t\tdelay: 1,\n\t\t\t\t\tmaxAttempts: 3,\n\t\t\t\t},\n\t\t\t);\n\t\t\texpect(!!(await waitForEvent(web3Provider, 'connect'))).toBe(true);\n\n\t\t\t// @ts-expect-error replace close handler\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\tweb3Provider._onCloseHandler = (_: CloseEvent) => {\n\t\t\t\t// @ts-expect-error replace close event\n\t\t\t\tweb3Provider._onCloseEvent({ code: 1002 });\n\t\t\t};\n\t\t\t// @ts-expect-error run protected method\n\t\t\tweb3Provider._removeSocketListeners();\n\t\t\t// @ts-expect-error run protected method\n\t\t\tweb3Provider._addSocketListeners();\n\t\t\tconst errorEvent = new Promise(resolve => {\n\t\t\t\tweb3Provider.on('error', (error: unknown) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\t\t\t\t\t\t(error as ProviderRpcError)?.message?.startsWith(\n\t\t\t\t\t\t\t'Maximum number of reconnect attempts reached',\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresolve(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tawait server.close();\n\t\t\tconst error = (await errorEvent) as Error;\n\t\t\texpect(error.message).toBe(`Maximum number of reconnect attempts reached! (${3})`);\n\t\t});\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/integration/web_socket_provider_integration.test.ts",["101"],["102"],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { Web3WSProviderError } from 'web3-errors';\nimport {\n\tEthExecutionAPI,\n\tJsonRpcId,\n\tJsonRpcNotification,\n\tJsonRpcResponse,\n\tJsonRpcSubscriptionResult,\n\tProviderRpcError,\n\tSocketRequestItem,\n\tWeb3APIPayload,\n} from 'web3-types';\nimport { Web3DeferredPromise } from 'web3-utils';\nimport WebSocketProvider from '../../src/index';\nimport {\n\tcreateTempAccount,\n\tdescribeIf,\n\tgetSystemTestProviderUrl,\n\tisWs,\n\twaitForCloseSocketConnection,\n\twaitForSocketConnect,\n} from '../fixtures/system_test_utils';\n\ntype Resolve = (value?: unknown) => void;\n\ndescribeIf(isWs)('WebSocketProvider - implemented methods', () => {\n\tlet clientWsUrl: string;\n\tlet tempAccount: string;\n\tlet webSocketProvider: WebSocketProvider;\n\tlet jsonRpcPayload: Web3APIPayload<EthExecutionAPI, 'eth_getBalance'>;\n\t// helper function\n\n\tbeforeAll(async () => {\n\t\tclientWsUrl = getSystemTestProviderUrl();\n\t\ttempAccount = (await createTempAccount()).address;\n\t});\n\tbeforeEach(() => {\n\t\tjsonRpcPayload = {\n\t\t\tjsonrpc: '2.0',\n\t\t\tid: 42,\n\t\t\tmethod: 'eth_getBalance',\n\t\t\tparams: [tempAccount, 'latest'],\n\t\t} as Web3APIPayload<EthExecutionAPI, 'eth_getBalance'>;\n\t\twebSocketProvider = new WebSocketProvider(\n\t\t\tclientWsUrl,\n\t\t\t{},\n\t\t\t{ delay: 1, autoReconnect: false, maxAttempts: 1 },\n\t\t);\n\t});\n\tafterEach(async () => {\n\t\t// make sure we try to close the connection after it is established\n\t\tif (webSocketProvider.getStatus() === 'connecting') {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t}\n\t\twebSocketProvider.disconnect(1000);\n\t});\n\n\tdescribe('websocker provider tests', () => {\n\t\tit('should connect', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\texpect(webSocketProvider).toBeInstanceOf(WebSocketProvider);\n\t\t\texpect(webSocketProvider.getStatus()).toBe('connected');\n\t\t});\n\t});\n\n\tdescribe('subscribe event tests', () => {\n\t\tit('should subscribe to `message` event', async () => {\n\t\t\tconst messagePromise = new Promise((resolve: Resolve) => {\n\t\t\t\twebSocketProvider.on(\n\t\t\t\t\t'message',\n\t\t\t\t\t(result?: JsonRpcSubscriptionResult | JsonRpcNotification<unknown>) => {\n\t\t\t\t\t\tif (result?.id !== jsonRpcPayload.id) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\texpect(result?.id).toBe(jsonRpcPayload.id);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t});\n\t\t\tawait webSocketProvider.request(jsonRpcPayload);\n\t\t\tawait messagePromise;\n\t\t});\n\n\t\tit('should subscribe to `error` event that could happen at the underlying WebSocket connection', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\tconst errorMsg = 'Custom WebSocket error occurred';\n\n\t\t\tconst errorPromise = new Promise((resolve: Resolve) => {\n\t\t\t\twebSocketProvider.on('error', (err: any) => {\n\t\t\t\t\texpect(err?.message).toBe(errorMsg);\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\twebSocketProvider['_socketConnection']?.emit(\n\t\t\t\t'error',\n\t\t\t\tnew Web3WSProviderError(errorMsg),\n\t\t\t);\n\t\t\tawait errorPromise;\n\t\t});\n\n\t\tit('should subscribe to `connect` event', async () => {\n\t\t\tconst openPromise = new Promise((resolve: Resolve) => {\n\t\t\t\twebSocketProvider.on('connect', () => {\n\t\t\t\t\tresolve('resolved');\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait expect(openPromise).resolves.toBe('resolved');\n\t\t});\n\n\t\tit('should subscribe to `disconnect` event', async () => {\n\t\t\tconst code = 1000;\n\n\t\t\tconst closePromise = new Promise<ProviderRpcError>(resolve => {\n\t\t\t\twebSocketProvider.on('disconnect', (error: ProviderRpcError) => {\n\t\t\t\t\texpect(error?.code).toEqual(code);\n\t\t\t\t\tresolve(error);\n\t\t\t\t});\n\t\t\t});\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\twebSocketProvider.disconnect(code);\n\t\t\tawait closePromise;\n\t\t});\n\n\t\tit('should error when no connection is established', async () => {\n\t\t\tconst wsProvider = new WebSocketProvider(\"ws://localhost:999\",{}, { autoReconnect: false });\n\t\t\tlet errored = false;\n\t\t\ttry{\n\t\t\t\tawait wsProvider.request(jsonRpcPayload);\n\t\t\t\t// should not be able to reach here\n\t\t\t\t\n\t\t\t}catch(e){\n\t\t\t\t// eslint-disable-next-line jest/no-conditional-expect\n\t\t\t\texpect((e as any).message).toBe('Connection not open')\n\t\t\t\terrored = true;\n\t\t\t}\n\t\t\texpect(errored).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('disconnect and reset test', () => {\n\t\tit('should disconnect', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\tconst provider = new WebSocketProvider(\n\t\t\t\tclientWsUrl,\n\t\t\t\t{},\n\t\t\t\t{ delay: 1, autoReconnect: false, maxAttempts: 1 },\n\t\t\t);\n\t\t\tawait waitForSocketConnect(provider);\n\t\t\tprovider.disconnect(1000);\n\t\t\tawait waitForCloseSocketConnection(provider);\n\t\t\texpect(provider.getStatus()).toBe('disconnected');\n\t\t});\n\n\t\tit('should reset', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\tclass TestReset extends WebSocketProvider {\n\t\t\t\tpublic pendingRequestsSize() {\n\t\t\t\t\treturn this._pendingRequestsQueue.size;\n\t\t\t\t}\n\n\t\t\t\tpublic sentRequestsSize() {\n\t\t\t\t\treturn this._pendingRequestsQueue.size;\n\t\t\t\t}\n\n\t\t\t\tpublic setPendingRequest(id: JsonRpcId, reqItem: SocketRequestItem<any, any, any>) {\n\t\t\t\t\tthis._pendingRequestsQueue.set(id, reqItem);\n\t\t\t\t}\n\n\t\t\t\tpublic setSentRequest(id: JsonRpcId, reqItem: SocketRequestItem<any, any, any>) {\n\t\t\t\t\tthis._sentRequestsQueue.set(id, reqItem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst testResetProvider = new TestReset(\n\t\t\t\tclientWsUrl,\n\t\t\t\t{},\n\t\t\t\t{ delay: 1, autoReconnect: false, maxAttempts: 1 },\n\t\t\t);\n\n\t\t\tawait waitForSocketConnect(testResetProvider);\n\n\t\t\tconst defPromise = new Web3DeferredPromise<JsonRpcResponse<ResponseType>>();\n\n\t\t\tconst reqItem: SocketRequestItem<any, any, any> = {\n\t\t\t\tpayload: jsonRpcPayload,\n\t\t\t\tdeferredPromise: defPromise,\n\t\t\t};\n\n\t\t\ttestResetProvider.setPendingRequest(jsonRpcPayload.id, reqItem);\n\t\t\texpect(testResetProvider.pendingRequestsSize()).toBe(1);\n\n\t\t\ttestResetProvider.setSentRequest(jsonRpcPayload.id, reqItem);\n\t\t\texpect(testResetProvider.sentRequestsSize()).toBe(1);\n\n\t\t\ttestResetProvider.reset();\n\t\t\texpect(testResetProvider.pendingRequestsSize()).toBe(0);\n\t\t\texpect(testResetProvider.sentRequestsSize()).toBe(0);\n\n\t\t\ttestResetProvider.disconnect(1000);\n\t\t});\n\t});\n\n\tdescribe('getStatus get and validate all status tests', () => {\n\t\tit('should getStatus `connecting`', async () => {\n\t\t\texpect(webSocketProvider.getStatus()).toBe('connecting');\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t});\n\n\t\tit('should getStatus `connected`', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\texpect(webSocketProvider.getStatus()).toBe('connected');\n\t\t});\n\t\tit('should getStatus `disconnected`', async () => {\n\t\t\tawait waitForSocketConnect(webSocketProvider);\n\t\t\twebSocketProvider.disconnect();\n\t\t\tawait waitForCloseSocketConnection(webSocketProvider);\n\t\t\texpect(webSocketProvider.getStatus()).toBe('disconnected');\n\t\t});\n\t});\n\tdescribe('send multiple Requests on same connection with valid payload and receive response tests', () => {\n\t\t// eslint-disable-next-line jest/expect-expect\n\t\tlet jsonRpcPayload2: Web3APIPayload<EthExecutionAPI, 'eth_mining'>;\n\t\tlet jsonRpcPayload3: Web3APIPayload<EthExecutionAPI, 'eth_hashrate'>;\n\t\tbeforeAll(() => {\n\t\t\tjsonRpcPayload2 = {\n\t\t\t\tjsonrpc: '2.0',\n\t\t\t\tid: 43,\n\t\t\t\tmethod: 'eth_mining',\n\t\t\t} as Web3APIPayload<EthExecutionAPI, 'eth_mining'>;\n\t\t\tjsonRpcPayload3 = {\n\t\t\t\tjsonrpc: '2.0',\n\t\t\t\tid: 44,\n\t\t\t\tmethod: 'eth_hashrate',\n\t\t\t} as Web3APIPayload<EthExecutionAPI, 'eth_hashrate'>;\n\t\t});\n\n\t\tit('should send multiple requests', async () => {\n\t\t\tconst prom1 = webSocketProvider.request(jsonRpcPayload);\n\n\t\t\tconst prom2 = webSocketProvider.request(jsonRpcPayload2);\n\n\t\t\tconst prom3 = webSocketProvider.request(jsonRpcPayload3);\n\n\t\t\tconst values = await Promise.all([prom1, prom2, prom3]);\n\t\t\texpect(values).toEqual(\n\t\t\t\texpect.arrayContaining([\n\t\t\t\t\texpect.objectContaining({ id: jsonRpcPayload.id }),\n\t\t\t\t\texpect.objectContaining({ id: jsonRpcPayload2.id }),\n\t\t\t\t\texpect.objectContaining({ id: jsonRpcPayload3.id }),\n\t\t\t\t]),\n\t\t\t);\n\n\t\t\t// Execute request in connected stated too\n\t\t\tconst prom3Value = await prom3;\n\t\t\texpect(prom3Value).toEqual(\n\t\t\t\texpect.objectContaining({\n\t\t\t\t\tid: jsonRpcPayload3.id,\n\t\t\t\t}),\n\t\t\t);\n\t\t});\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/__mocks__/isomorphic-ws.ts",[],[],"/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/check_implementation.test.ts",["103"],[],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport WebSocket from 'isomorphic-ws';\nimport WebSocketProvider from '../../src/index';\n\njest.mock('isomorphic-ws');\ndescribe('WebSocketProvider', () => {\n\tlet send: () => void;\n\tbeforeAll(() => {\n\t\tsend = jest.fn();\n\t\tjest.spyOn(WebSocket.prototype, 'send').mockImplementation(send);\n\t});\n\n\tdescribe('methods', () => {\n\t\tit.each(['_openSocketConnection', '_addSocketListeners'])(\n\t\t\t'should call method %s',\n\t\t\tmethod => {\n\t\t\t\tconst _method = jest.fn();\n\t\t\t\t// @ts-expect-error mock method\n\t\t\t\tjest.spyOn(WebSocketProvider.prototype, method).mockImplementation(_method);\n\t\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\t\texpect(ws).toBeDefined();\n\t\t\t\texpect(_method).toHaveBeenCalled();\n\t\t\t},\n\t\t);\n\t\tit('should construct with expected methods', () => {\n\t\t\tconst _closeSocketConnection = jest.fn();\n\t\t\tconst _removeSocketListeners = jest.fn();\n\t\t\tconst _onDisconnect = jest.fn();\n\t\t\tconst code = 1002;\n\t\t\tconst data = 'data';\n\t\t\t// @ts-expect-error mock method\n\t\t\tjest.spyOn(WebSocketProvider.prototype, '_closeSocketConnection').mockImplementation(\n\t\t\t\t_closeSocketConnection,\n\t\t\t);\n\t\t\t// @ts-expect-error mock method\n\t\t\tjest.spyOn(WebSocketProvider.prototype, '_removeSocketListeners').mockImplementation(\n\t\t\t\t_removeSocketListeners,\n\t\t\t);\n\t\t\t// @ts-expect-error mock method\n\t\t\tjest.spyOn(WebSocketProvider.prototype, '_onDisconnect').mockImplementation(\n\t\t\t\t_onDisconnect,\n\t\t\t);\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\texpect(ws.getStatus()).toBe('connected');\n\t\t\tws.disconnect(code, data);\n\t\t\texpect(_removeSocketListeners).toHaveBeenCalled();\n\t\t\texpect(_onDisconnect).toHaveBeenCalledWith(code, data);\n\t\t\texpect(_closeSocketConnection).toHaveBeenCalledWith(code, data);\n\t\t});\n\t\tit('getStatus', () => {\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\texpect(ws.getStatus()).toBe('connected');\n\t\t\t// @ts-expect-error mock field\n\t\t\tws._socketConnection.readyState = 0;\n\t\t\texpect(ws.getStatus()).toBe('connecting');\n\t\t\t// @ts-expect-error mock field\n\t\t\tws._socketConnection.readyState = 2;\n\t\t\texpect(ws.getStatus()).toBe('disconnected');\n\t\t\t// @ts-expect-error mock field\n\t\t\tws._socketConnection = undefined;\n\t\t\texpect(ws.getStatus()).toBe('disconnected');\n\t\t});\n\t\tit('socketConnection.close', () => {\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\tconst close = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.close = close;\n\t\t\tconst code = 1002;\n\t\t\tconst data = 'data';\n\t\t\tws.disconnect(code, data);\n\t\t\texpect(close).toHaveBeenCalledWith(code, data);\n\t\t});\n\t\tit('onCloseEvent autoReconnect=false', () => {\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545', {}, { autoReconnect: false });\n\t\t\tconst _clearQueues = jest.fn();\n\t\t\tconst _removeSocketListeners = jest.fn();\n\t\t\tconst _onDisconnect = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.close = jest.fn();\n\t\t\t\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._clearQueues = _clearQueues;\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._removeSocketListeners = _removeSocketListeners;\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._onDisconnect = _onDisconnect;\n\n\t\t\tconst code = 1002;\n\t\t\tconst data = 'data';\n\t\t\t// @ts-expect-error emit method\n\t\t\tws._socketConnection.emit('close', { code, reason: data });\n\t\t\texpect(_clearQueues).toHaveBeenCalledWith({ code, reason: data });\n\t\t\texpect(_removeSocketListeners).toHaveBeenCalled();\n\t\t\texpect(_onDisconnect).toHaveBeenCalledWith(code, data);\n\t\t});\n\t\tit('onCloseEvent autoReconnect=true', () => {\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\tconst _reconnect = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.close = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._reconnect = _reconnect;\n\n\t\t\tconst code = 1002;\n\t\t\tconst data = 'data';\n\t\t\t// @ts-expect-error emit event\n\t\t\tws._socketConnection.emit('close', { code, reason: data });\n\t\t\texpect(_reconnect).toHaveBeenCalled();\n\t\t});\n\t\tit('listeners', () => {\n\t\t\tconst ws = new WebSocketProvider('ws://localhost:8545');\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.listeners = () => {\n\t\t\t\t\tthrow new Error('error');\n\t\t\t};\n\t\t\tconst addEventListener = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.addEventListener = addEventListener;\n\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._addSocketListeners();\n\t\t\t// @ts-expect-error mock method\n\t\t\texpect(addEventListener).toHaveBeenCalledWith('error', ws._onErrorHandler);\n\t\t\tconst removeEventListener = jest.fn();\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._socketConnection.removeEventListener = removeEventListener;\n\t\t\t// @ts-expect-error mock method\n\t\t\tws._removeSocketListeners();\n\t\t\t// @ts-expect-error mock method\n\t\t\texpect(removeEventListener).toHaveBeenCalledWith('message', ws._onMessageHandler);\n\t\t\t// @ts-expect-error mock method\n\t\t\texpect(removeEventListener).toHaveBeenCalledWith('open', ws._onOpenHandler);\n\t\t\t// @ts-expect-error mock method\n\t\t\texpect(removeEventListener).toHaveBeenCalledWith('close', ws._onCloseHandler);\n\t});\n\t});\n});\n","/Users/alexeykosinski/work/chainsafe/web3.js/packages/web3-providers-ws/test/unit/web_socket_provider.test.ts",["104"],[],"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport WebSocket from 'isomorphic-ws';\nimport { EthExecutionAPI, Web3APIPayload } from 'web3-types';\nimport WebSocketProvider from '../../src/index';\nimport {\n\tinvalidConnectionStrings,\n\tvalidConnectionStrings,\n\twsProviderOptions,\n} from '../fixtures/test_data';\n\njest.mock('isomorphic-ws');\n\ndescribe('WebSocketProvider', () => {\n\tlet wsProvider: WebSocketProvider;\n\tlet jsonRpcPayload: Web3APIPayload<EthExecutionAPI, 'eth_getBalance'>;\n\tlet jsonRpcResponse: Record<string, unknown>;\n\n\tbeforeEach(() => {\n\t\tjest.spyOn(WebSocket.prototype, 'send');\n\n\t\twsProvider = new WebSocketProvider('ws://localhost:8545');\n\n\t\tjsonRpcPayload = {\n\t\t\tjsonrpc: '2.0',\n\t\t\tid: 42,\n\t\t\tmethod: 'eth_getBalance',\n\t\t\tparams: ['0x407d73d8a49eeb85d32cf465507dd71d507100c1', 'latest'],\n\t\t};\n\t\tjsonRpcResponse = { ...jsonRpcPayload, result: JSON.stringify(jsonRpcPayload) };\n\t});\n\n\tdescribe('constructor', () => {\n\t\tit('should construct with expected methods', () => {\n\t\t\texpect(wsProvider.request).toBeDefined();\n\t\t\texpect(wsProvider.getStatus).toBeDefined();\n\t\t\texpect(wsProvider.supportsSubscriptions).toBeDefined();\n\t\t\texpect(wsProvider.request).toBeDefined();\n\t\t\texpect(wsProvider.on).toBeDefined();\n\t\t\texpect(wsProvider.removeListener).toBeDefined();\n\t\t\texpect(wsProvider.once).toBeDefined();\n\t\t\texpect(wsProvider.removeAllListeners).toBeDefined();\n\t\t\texpect(wsProvider.connect).toBeDefined();\n\t\t\texpect(wsProvider.disconnect).toBeDefined();\n\t\t\texpect(wsProvider.reset).toBeDefined();\n\t\t\texpect(wsProvider.SocketConnection).toBeInstanceOf(WebSocket);\n\t\t});\n\n\t\tit('should allow for providerOptions to be passed upon instantiation', () => {\n\t\t\texpect(\n\t\t\t\t() => new WebSocketProvider('ws://localhost:8545', wsProviderOptions),\n\t\t\t).not.toThrow();\n\t\t});\n\n\t\tit.each(validConnectionStrings)(\n\t\t\t'should instantiation with valid client - %s',\n\t\t\tvalidClient => {\n\t\t\t\texpect(() => new WebSocketProvider(validClient)).not.toThrow();\n\t\t\t},\n\t\t);\n\n\t\tit.each(invalidConnectionStrings)(\n\t\t\t'should instantiation with invalid client - %s',\n\t\t\tinvalidClient => {\n\t\t\t\texpect(\n\t\t\t\t\t() =>\n\t\t\t\t\t\t// @ts-expect-error - Purposefully passing invalid types to check validation\n\t\t\t\t\t\tnew WebSocketProvider(invalidClient),\n\t\t\t\t).toThrow(`Client URL \"${invalidClient as unknown as string}\" is invalid.`);\n\t\t\t},\n\t\t);\n\t});\n\n\tdescribe('supportsSubscriptions', () => {\n\t\tit('should return true', () => {\n\t\t\texpect(wsProvider.supportsSubscriptions()).toBe(true);\n\t\t});\n\t});\n\n\tdescribe('request', () => {\n\t\tdescribe('success response', () => {\n\t\t\tit('should return expected response', async () => {\n\t\t\t\tconst result = await wsProvider.request(jsonRpcPayload);\n\n\t\t\t\texpect(result).toEqual(jsonRpcResponse);\n\t\t\t});\n\t\t});\n\t});\n});\n",{"ruleId":"105","severity":2,"message":"106","line":77,"column":2,"nodeType":"107","messageId":"108","endLine":77,"endColumn":33,"suppressions":"109"},{"ruleId":"110","severity":2,"message":"111","line":89,"column":2,"nodeType":"112","messageId":"113","endLine":95,"endColumn":3,"suppressions":"114"},{"ruleId":"115","severity":2,"message":"116","line":41,"column":30,"nodeType":"117","messageId":"118","endLine":41,"endColumn":32,"suppressions":"119"},{"ruleId":"120","severity":2,"message":"121","line":21,"column":1,"nodeType":"122","endLine":26,"endColumn":28,"suppressions":"123"},{"ruleId":"120","severity":2,"message":"124","line":29,"column":1,"nodeType":"122","endLine":29,"endColumn":49,"suppressions":"125"},{"ruleId":"120","severity":2,"message":"126","line":31,"column":1,"nodeType":"122","endLine":31,"endColumn":66,"suppressions":"127"},{"ruleId":"120","severity":2,"message":"128","line":33,"column":1,"nodeType":"122","endLine":33,"endColumn":41,"suppressions":"129"},{"ruleId":"120","severity":2,"message":"130","line":55,"column":1,"nodeType":"122","endLine":55,"endColumn":46,"suppressions":"131"},{"ruleId":"120","severity":2,"message":"132","line":57,"column":1,"nodeType":"122","endLine":57,"endColumn":25,"suppressions":"133"},{"ruleId":"120","severity":2,"message":"134","line":60,"column":1,"nodeType":"122","endLine":60,"endColumn":60,"suppressions":"135"},{"ruleId":"120","severity":2,"message":"136","line":62,"column":1,"nodeType":"122","endLine":62,"endColumn":48,"suppressions":"137"},{"ruleId":"120","severity":2,"message":"138","line":64,"column":1,"nodeType":"122","endLine":64,"endColumn":50,"suppressions":"139"},{"ruleId":"140","severity":2,"message":"141","line":72,"column":2,"nodeType":"142","messageId":"143","endLine":72,"endColumn":21,"suppressions":"144"},{"ruleId":"145","severity":2,"message":"146","line":74,"column":2,"nodeType":"147","messageId":"148","endLine":74,"endColumn":56,"suppressions":"149"},{"ruleId":"150","severity":2,"message":"151","line":74,"column":19,"nodeType":"152","messageId":"153","endLine":74,"endColumn":30,"suppressions":"154"},{"ruleId":"155","severity":2,"message":"156","line":152,"column":4,"nodeType":"157","messageId":"158","endLine":152,"endColumn":20,"suppressions":"159"},{"ruleId":"160","severity":2,"message":"161","line":152,"column":4,"nodeType":"162","messageId":"163","endLine":152,"endColumn":18,"suppressions":"164"},{"ruleId":"165","severity":2,"message":"166","line":491,"column":4,"nodeType":"167","messageId":"168","endLine":496,"endColumn":6,"suppressions":"169"},{"ruleId":"145","severity":2,"message":"146","line":505,"column":2,"nodeType":"170","messageId":"148","endLine":508,"endColumn":3,"suppressions":"171"},{"ruleId":"145","severity":2,"message":"146","line":507,"column":38,"nodeType":"147","messageId":"148","endLine":507,"endColumn":90,"suppressions":"172"},{"ruleId":"173","severity":2,"message":"174","line":35,"column":2,"nodeType":"175","endLine":35,"endColumn":6,"suppressions":"176"},{"ruleId":"177","severity":1,"message":"178","line":20,"column":8,"nodeType":"179","endLine":20,"endColumn":25},{"ruleId":"177","severity":1,"message":"178","line":20,"column":8,"nodeType":"179","endLine":20,"endColumn":25},{"ruleId":"177","severity":1,"message":"178","line":30,"column":8,"nodeType":"179","endLine":30,"endColumn":25},{"ruleId":"160","severity":2,"message":"180","line":49,"column":5,"nodeType":"162","messageId":"181","endLine":49,"endColumn":22,"suppressions":"182"},{"ruleId":"183","severity":1,"message":"184","line":49,"column":42,"nodeType":"162","messageId":"185","endLine":49,"endColumn":55,"suppressions":"186"},{"ruleId":"115","severity":2,"message":"187","line":301,"column":27,"nodeType":"117","messageId":"118","endLine":301,"endColumn":29,"suppressions":"188"},{"ruleId":"115","severity":2,"message":"187","line":399,"column":44,"nodeType":"117","messageId":"118","endLine":399,"endColumn":46,"suppressions":"189"},{"ruleId":"115","severity":2,"message":"187","line":405,"column":74,"nodeType":"117","messageId":"118","endLine":405,"endColumn":76,"suppressions":"190"},{"ruleId":"177","severity":1,"message":"178","line":20,"column":8,"nodeType":"179","endLine":20,"endColumn":25},{"ruleId":"183","severity":1,"message":"184","line":118,"column":36,"nodeType":"162","messageId":"185","endLine":118,"endColumn":49,"suppressions":"191"},{"ruleId":"177","severity":1,"message":"178","line":30,"column":8,"nodeType":"179","endLine":30,"endColumn":25},{"ruleId":"192","severity":2,"message":"193","line":150,"column":5,"nodeType":"170","messageId":"194","endLine":150,"endColumn":59,"suppressions":"195"},{"ruleId":"177","severity":1,"message":"178","line":18,"column":8,"nodeType":"179","endLine":18,"endColumn":25},{"ruleId":"177","severity":1,"message":"178","line":19,"column":8,"nodeType":"179","endLine":19,"endColumn":25},"class-methods-use-this","Expected 'this' to be used by class method '_validateProviderPath'.","FunctionExpression","missingThis",["196"],"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor",["197"],"@typescript-eslint/no-empty-function","Unexpected empty async arrow function.","ArrowFunctionExpression","unexpected",["198"],"import/no-extraneous-dependencies","'web3-eth-accounts' should be listed in the project's dependencies. Run 'npm i -S web3-eth-accounts' to add it","ImportDeclaration",["199"],"'web3-hardhat-plugin' should be listed in the project's dependencies. Run 'npm i -S web3-hardhat-plugin' to add it",["200"],"'web3-eth' should be listed in the project's dependencies. Run 'npm i -S web3-eth' to add it",["201"],"'web3-core' should be listed in the project's dependencies. Run 'npm i -S web3-core' to add it",["202"],"'web3-eth-personal' should be listed in the project's dependencies. Run 'npm i -S web3-eth-personal' to add it",["203"],"'web3' should be listed in the project's dependencies. Run 'npm i -S web3' to add it",["204"],"'web3-eth-contract' should be listed in the project's dependencies. Run 'npm i -S web3-eth-contract' to add it",["205"],"'web3-providers-http' should be listed in the project's dependencies. Run 'npm i -S web3-providers-http' to add it",["206"],"'web3-providers-ipc' should be listed in the project's dependencies. Run 'npm i -S web3-providers-ipc' to add it",["207"],"@typescript-eslint/ban-ts-comment","Include a description after the \"@ts-expect-error\" directive to explain why the @ts-expect-error is necessary. The description must be 3 characters or longer.","Line","tsDirectiveCommentRequiresDescription",["208"],"@typescript-eslint/no-unsafe-return","Unsafe return of an `any` typed value.","ConditionalExpression","unsafeReturn",["209"],"@typescript-eslint/no-unsafe-call","Unsafe call of an `any` typed value.","MemberExpression","unsafeCall",["210"],"no-plusplus","Unary operator '++' used.","UpdateExpression","unexpectedUnaryOp",["211"],"no-param-reassign","Assignment to function parameter 'currentAttempt'.","Identifier","assignmentToFunctionParam",["212"],"no-await-in-loop","Unexpected `await` inside a loop.","AwaitExpression","unexpectedAwait",["213"],"CallExpression",["214"],["215"],"no-null/no-null","Use undefined instead of null","Literal",["216"],"import/no-named-as-default","Using exported name 'WebSocketProvider' as identifier for default export.","ImportDefaultSpecifier","Assignment to property of function parameter 'webSocketProvider'.","assignmentToFunctionParamProp",["217"],"@typescript-eslint/no-unused-vars","'_' is defined but never used.","unusedVar",["218"],"Unexpected empty arrow function.",["219"],["220"],["221"],["222"],"jest/no-conditional-expect","Avoid calling `expect` conditionally`","conditionalExpect",["223"],{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},{"kind":"224","justification":"225"},"directive",""]